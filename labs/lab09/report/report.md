---
## Front matter
title: "Лабораторная работа №9"
subtitle: "Понятие подпрограммы. Отладчик GDB"
author: "Коровкин Никита  Михайлович"

## Generic otions
lang: ru-RU
toc-title: "Содержание"

## Bibliography
bibliography: bib/cite.bib
csl: pandoc/csl/gost-r-7-0-5-2008-numeric.csl

## Pdf output format
toc: true # Table of contents
toc-depth: 2
lof: true # List of figures
lot: true # List of tables
fontsize: 12pt
linestretch: 1.5
papersize: a4
documentclass: scrreprt
## I18n polyglossia
polyglossia-lang:
  name: russian
  options:
	- spelling=modern
	- babelshorthands=true
polyglossia-otherlangs:
  name: english
## I18n babel
babel-lang: russian
babel-otherlangs: english
## Fonts
mainfont: IBM Plex Serif
romanfont: IBM Plex Serif
sansfont: IBM Plex Sans
monofont: IBM Plex Mono
mathfont: STIX Two Math
mainfontoptions: Ligatures=Common,Ligatures=TeX,Scale=0.94
romanfontoptions: Ligatures=Common,Ligatures=TeX,Scale=0.94
sansfontoptions: Ligatures=Common,Ligatures=TeX,Scale=MatchLowercase,Scale=0.94
monofontoptions: Scale=MatchLowercase,Scale=0.94,FakeStretch=0.9
mathfontoptions:
## Biblatex
biblatex: true
biblio-style: "gost-numeric"
biblatexoptions:
  - parentracker=true
  - backend=biber
  - hyperref=auto
  - language=auto
  - autolang=other*
  - citestyle=gost-numeric
## Pandoc-crossref LaTeX customization
figureTitle: "Рис."
tableTitle: "Таблица"
listingTitle: "Листинг"
lofTitle: "Список иллюстраций"
lotTitle: "Список таблиц"
lolTitle: "Листинги"
## Misc options
indent: true
header-includes:
  - \usepackage{indentfirst}
  - \usepackage{float} # keep figures where there are in the text
  - \floatplacement{figure}{H} # keep figures where there are in the text
---

# Цель работы

Ознакомиться с понятием подпрограмм в Ассемблере и научиться использовать подпрограммы на практике. Ознакомиться с отладчиком gdb и научиться использовать его

                                                   |


# Выполнение лабораторной работы

Сперва создадим рабочую директорию и первый файл: с которым мы будем работать.(рис.1)

![Создание рабочей директории и файла lab9-1.asm](image/1.png)

Далее подключим in_out.asm, перенеся его из папки прошлой лабораторной работы.(рис.2)

![Копирование файла in_out.asm в рабочую папку](image/2.png)

Откроем файл и вставим код из первого листинга.(рис.3)

![Вставляем код из первого листинга](image/3.png)

Теперь соберем файл и запустим его.(рис.4)

![Запуск файла](image/4.png)

Затем изменим файл, чтобы в подпрограмме была ещё одна подпрограмма, вычисляющая значение g(x), которая будет передавать значение в первую подпрограмму, которая бы уже вычислила значение f(g(x)).(рис.5)

![Изменение кода файла lab9-1.asm](image/5.png)

Запустим программу еще раз.(рис.6)

![Повторный запуск файла lab9-1.asm](image/6.png)

Все работает верно.

Теперь создадим второй файл.(рис.7)

![Создание второго файла](image/7.png)

Вставим туда код из листинга.(рис.8)

![Изменение файла lab9-2.asm](image/8.png)

Запустим файл.(рис.9)

![Запуск файла lab9-2.asm](image/9.png)

Теперь загрузим программу  в gdb.(рис.10)

![Загрузка программы в gdb](image/10.png)

Запустим ее в отладчике.(рис.11)

![Запуск программы в отладчике](image/11.png)

После запуска создадим брейкпоинт на метке _start с помощью команды break.(рис.12)

![Создание брейкпоинта](image/12.png)

С помощью команды disassemble дизассемблируем метку.(рис.13)

![Дизассемблирование](image/13.png)

При помощи следующей команды переключаем синтаксис вывода на  intel(рис.14)

![Переключение синтаксиса](image/14.png)

Дизассемблиурем программу еще раз(рис.15)

![Повторное дизассемблирование программы](image/15.png)

Теперь включаем графическое отображение кода.(рис.16)

![Графическое отображение кода](image/16.png)

Включаем графическое отображение значений регистров.(рис.17)

![Графическое отображение регистров](image/17.png)

Выведем отображение информации о имеющихся брейкпоинтах.(рис.18)

![Отображение информации о брейкпоинтах](image/18.png)

А теперь создадим брейкпоинт самостоятельно.(рис.19)

![Создание брейкпоинта по адресу](image/19.png)

Выведем информацию о брейкпоинтах еще раз.(рис.20)

![Повторных вывод информации о  брейкпоинтах](image/20.png)

Воспользуемся командой si для построчного выполнения кода. Задействуем ее 5 раз.(рис.21-22)

![Построчное выполнение кода](image/21.png)

![Построчное выполнение кода](image/22.png)

Как видим, поменялись значения регистров eax, ecx, edx и ebx. Теперь выведем информацию о значениях регистров(рис.23)

![Изменение значений регистров](image/23.png)

Теперь выведем значение переменной по имени и по адресу.(рис.24-25)

![Вывод значения переменной по имени](image/24.png)

![Вывод значения переменной по адресу](image/25.png)

После этого изменим первый символ переменной.(рис.26)

![Изменение первого символа](image/26.png)

А затем изменим несколько символов переменной, обращаясь по адресу.(рис.27)

![Изменение нескольких символов](image/27.png)

Теперь предстоит  вывести значение регистра в изначальном, двоичном и шестнадцатиричном виде(рис.28)

![Вывод значения регистра в разном виде](image/28.png)

Изменим значение регистра.(рис.29)

![Изменение значения регистра](image/29.png)

Нетрудно заметить, что в регистр записались разные значения, так как в одном случае мы записываем туда число -  в другом строку.

Завершаем работу программы с помощью continue и выходим из отладчика.(рис.30)

![Завершение работы](image/30.png)

Теперь скопируем файл из предыдущей лабораторной работы.(рис.21)

![Копирование предыдущей лабораторной работы](image/31.png)

Мы так же соберем его и загрузим в gdb.(рис.32)

![Загрузка файла предыдущей работы в gdb](image/32.png)

Теперь создаем брейкпоинт и запускаем программу.(рис.33)

![Запуск программы](image/33.png)

Затем выведем значение регистра esp, где хранятся данные о стеке.(рис.34)

![Вывод значения регистра](image/34.png)

Теперь нужно вывести значение всех элементов стека.(рис.35)

![Вывод значений всех элементов стека](image/35.png)

Можно заметить, что для вывода каждого элемента нужно менять значения адреса с шагом на 4. Это связано с тем, что под каждый элемент выделяется 4 байта.

#Выполнение самостоятельной работы

Первым делом копируем файл задания из прошлой лабораторной работы.(рис.36)

![Копируем файл из предыдущей работы](image/36.png)

Его код выглядит так.(рис.37)

![Код в файле](image/xxx.png)

Теперь соберем код и проверим.(рис.38)

![Запуск кода](image/38.png)

Создадим второй файл.(рис.39)

![Второй файл](image/39.png)

Вставляем в него код из листинга.(рис.40)

![Вставляем код из листинга](image/40.png)

Запускаем файл.(рис.41)

![Запуск второго файла](image/41.png)

Вставим наш файл в gdb(рис.42)

![Вставляем файл в gdb](image/42.png)

Переключаем на синтаксис и включаем графическое отображение.(рис.43)

![Переключение синтаксиса и включение графического отображения](image/44.png)

Затем устанавливаем брейкпоинт(рис.44)
![Устанавливаем брейкпоинт](image/45.png)

Начинаем выполнение кода.(рис.45-46)

![Выполнение кода](image/46.png)

![Выполнение кода](image/47.png)

Нетрудно заметить,что мы должны были умножить значение регистра ebx, но сделали это с eax.

Отредактируем код и запустим снова.(рис.47)

![Повторный запуск](image/47.png)

Все вывелось верно. Работа сделана правильно.





# Выводы

В результате выполнения данной лабораторной работы мы научились использовать подпрограммы, узнали как пользоваться отладчиком и изучили его функции.
